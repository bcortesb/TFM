# ================================================================
# BGScript: Heartrate script
# ----------------------------------------------------------------
# CHANGELOG:
#	- Reset needs to be implemented
#	- ADC convertion equation needs to be performed
#   
# ================================================================
dim result
dim input
dim adcvalue
dim hrvalue
dim count
dim rep
dim tx,rx
dim ltx,lrx
dim f,t
dim display(80)
dim tmp(5)
dim offset


dim connected

#max (for the buffer): 256 bytes. Store every 2ms till 126ms
dim hr_data(252)

#for testing
dim test(5)
dim value
dim pos

# LED pins:
# (output)LED Bluetooth:
const led_port_Bluetooth	= 1
const led_mask_Bluetooth	= $0004
const led_pin_nbr_Bluetooth	= 3
# (output)LED TX:
const led_port_TX		= 1
const led_mask_TX		= $0008
const led_pin_nbr_TX	= 4
# (output)LED Disconnect:
const led_port_Disc		= 1
const led_mask_Disc		= $0010
const led_pin_nbr_Disc	= 5

# (Input) Reset:
const reset_button_port		= 1
const reset_button_mask		= $0020
const reset_button_pin_nbr	= 6


# Boot event listener - Generated when the module is started
event system_boot(major, minor, patch, build, bootloader, hw)

	# Write welcome message to UART interface at boot
    call endpoint_send(0,20,"HEART RATE START\r\n")

    # Configure LEDs pins as GPIO output
    call hardware_configure_gpio(led_port_Bluetooth, led_pin_nbr_Bluetooth, hardware_gpio_output,hardware_gpio_float)
	call hardware_configure_gpio(led_port_TX, led_pin_nbr_TX, hardware_gpio_output,hardware_gpio_float)
	call hardware_configure_gpio(led_port_Disc, led_pin_nbr_Disc, hardware_gpio_output,hardware_gpio_float)
	
	# Configure reset input
	call hardware_configure_gpio(reset_button_port, reset_button_pin_nbr, hardware_gpio_input,hardware_gpio_float)


    # By default stream data to DROP endpoint meaning the data will be ignored
    call endpoint_set_streaming_destination(3,31)
    call endpoint_set_streaming_destination(0,31)

end

#generated when bluetooth radio is ready to use
event system_initialized(addr)

	count = 1
	
	#for test
	value=0
	pos=0
	
	# Set local Bluetooth friendly name for Bluetooth classic
    call system_set_local_name(18,"BT121 HTM+SPP Demo")
	
	# Start RFCOMM (SPP) server with SDP ID 2
    call bt_rfcomm_start_server(2,0)
    
    # Set Bluetooth classic mode to visible and connectable
    call bt_gap_set_mode(1,1,0)
    
    # Start Bluetooth LE advertisements and enable connections
    call le_gap_set_mode(2,2)

    # Configure Bluetooth Security Manager
    # No MITM required, no input/output -> Just Works pairing mode
    call sm_configure(0,3)
    # Enable bonding mode
    call sm_set_bondable_mode(1)
	
    # set timer, time interval between events is 126ms
    call hardware_set_soft_timer(126,0,0)

    # start another timer, this fast timer is used to drive LED.
    call hardware_set_soft_timer(2,1,0)    # interval = 2 ms, handle = 1, timer is repeating
	# 2 ms -> 500Hz -> Frequency for ECG read
	
	# start another timer: for testing
    call hardware_set_soft_timer(21,2,0)    # interval = 21 ms, handle = 2, timer is repeating
	

    # set connectable and discoverable mode
    call le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable)
end

# Event listener for endpoint status changes
# These events are generated for example when SPP connection is opened
event endpoint_status(endpoint,type,destination,flags)

    # Endpoint status has changed to RFCOMM and become active
    # This means SPP connection has been received
    if (type = endpoint_rfcomm)  && (flags&ENDPOINT_FLAG_ACTIVE)

        # Store endpoint ID
        rep=endpoint

        display(40+13:2)="BT"

        # Write a message to UART interface to indicate SPP connection
        call endpoint_send(0,15,"SPP CONNECTED\r\n")
        
        # Send a welcome message to Bluetooth SPP connection
        call endpoint_send(endpoint,29,"Connected to BT121 SPP DEMO\r\n")
        
        # Configure data streaming from UART to SPP connection - enable transparent SPP mode
        call endpoint_set_streaming_destination(0,endpoint)
    end if
end

# This event is generated when an endpoint is closing
# for example when SPP connection is closed
event endpoint_closing(reason,endpoint)

    # Close endpoint also in the module
    call endpoint_close(endpoint)

    # If RFCOMM endpoint is closing, which means SPP connection is closed
    # Write a message to UART
    if(endpoint = rep)
        display(40+13:2)="  "
        call endpoint_send(0,18,"SPP DISCONNECTED\r\n")
    end if
end

#generated when timer has lapsed
event hardware_soft_timer(handle)
    
	if handle = 1 then
        # the fast 2ms timer that is used to drive the devkit LED has lapsed.
		
		# System reques ADC read operation
		#	12 effective bits, range = [-2048, +2047] when right-alligned
		#	Internal 1.24V reference
		call hardware_read_adc(4) (result,input,adcvalue)
		
		
		if result = 0 then #Result=0 successful
            # convert raw ADC reading to heart rate value (adc value range is 0..4095 -> hrvalue range is 20..183)
			# AJUSTAR ESTA ECUACION A LOS VALORES DE VOLTAJE QUE SE RECIBEN
			# ADC value is 12 MSB
            hrvalue = adcvalue / 16
			
			# Calculate heart ECG
			# ADC*V_ref/ADC_max * V_coeff + offset
			hrvalue = (10*hrvalue*1240/2047) * 10/45 + offset
        else #error
            # if ADC read is unsuccessful, response value is 0
            hrvalue = 0
        end if
		
		hr_data(0:1)=0	# flags. zero means heart rate is sent as 8-bit value and no extra info is sent
		hr_data(count:4)=float(hrvalue,-1)	#Deformation value storage every 2ms and sended every 500ms to the app
		count = count + 4
			
    end if
	

	if handle = 2 then
		#for testing
		value=value+1
		test(pos:4)=float(value,-1)
		pos=pos+4		
		
	end if
	
    if handle = 0 then
        # the slow timer at 126ms has lapsed
		count = 1
		pos=0

		#$ff: To all connected devices; xgatt_hr: characteristic handle;
        call gatt_server_send_characteristic_notification($ff, xgatt_hr, 2, hr_data(0:252))
		#LED TX on
		call hardware_write_gpio(led_port_TX,led_mask_TX,led_mask_TX)
		
		call endpoint_send(rep,252,hr_data(0:252))
		call endpoint_send(0,20,"p1\r\n")
		call endpoint_send(0,20,test(0:5))
		
    end if

end

# generated when new connection is opened
event le_connection_opened(address,address_type,master,connection,bonding)
    call endpoint_send(0, 9, "Connect\r\n")

	# Write a message to UART interface to indicate SPP connection
    call endpoint_send(0,15,"HeartRate CONNECTED\r\n")
		
    connected = 1
	if connected = 1 then
		#Bluetooth led on when connection is on
		call hardware_write_gpio(led_port_Bluetooth,led_mask_Bluetooth,led_mask_Bluetooth)
	end if
	
end

# generated when the connection is closed
event le_connection_closed(reason,connection)

    call endpoint_send(0, 12, "Disconnect\r\n")

    # connection closed, restart advertisement
    call le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable) 

    connected = 0
	
	if connected = 0 then
		#Bluetooth led off when connection is off
		call hardware_write_gpio(led_port_Bluetooth,led_mask_Bluetooth,$0000)
	end if
	
end
