# ================================================================
# BGScript: Heartrate script
# ----------------------------------------------------------------
# CHANGELOG:
#	- Reset needs to be implemented
#	- ADC convertion equation needs to be performed
#   
# ================================================================
dim result
dim input
dim adcvalue
dim hrvalue
dim count

dim connected

#max: 256 bytes. Store every 2ms till 500ms
dim hr_data(250)

# LED pins:
# (output)LED Bluetooth:
const led_port_Bluetooth	= 1
const led_mask_Bluetooth	= $0004
const led_pin_nbr_Bluetooth	= 3
# (output)LED TX:
const led_port_TX		= 1
const led_mask_TX		= $0008
const led_pin_nbr_TX	= 4
# (output)LED Disconnect:
const led_port_Disc		= 1
const led_mask_Disc		= $0010
const led_pin_nbr_Disc	= 5

# (Input) Reset:
const reset_button_port		= 1
const reset_button_mask		= $0020
const reset_button_pin_nbr	= 6

# Boot event listener - Generated when the module is started
event system_boot(major, minor, patch, build, bootloader, hw)

	# Write welcome message to UART interface at boot
    call endpoint_send(0,20,"HEART RATE START\r\n")

    # Configure LEDs pins as GPIO output
    call hardware_configure_gpio(led_port_Bluetooth, led_pin_nbr_Bluetooth, hardware_gpio_output,hardware_gpio_float)
	call hardware_configure_gpio(led_port_TX, led_pin_nbr_TX, hardware_gpio_output,hardware_gpio_float)
	call hardware_configure_gpio(led_port_Disc, led_pin_nbr_Disc, hardware_gpio_output,hardware_gpio_float)
	
	# Configure reset input
	call hardware_configure_gpio(reset_button_port, reset_button_pin_nbr, hardware_gpio_input,hardware_gpio_float)


    # By default stream data to DROP endpoint meaning the data will be ignored
    call endpoint_set_streaming_destination(3,31)
    call endpoint_set_streaming_destination(0,31)

end

#generated when bluetooth radio is ready to use
event system_initialized(addr)

	count = 0
	
    # set timer, time interval between events is 500ms
    call hardware_set_soft_timer(500,0,0)

    # start another timer, this fast timer is used to drive LED.
    call hardware_set_soft_timer(2,1,0)    # interval = 2 ms, handle = 1, timer is repeating
	# 2 ms -> 500Hz -> Frequency for ECG read

    # set connectable and discoverable mode
    call le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable)
end


#generated when timer has lapsed
event hardware_soft_timer(handle)
    
	if handle = 1 then
        # the fast 2ms timer that is used to drive the devkit LED has lapsed.
		call hardware_read_adc(4) (result,input, adcvalue)
		count = count + 1
		
		if result = 0 then #Result=0 successful
            # convert raw ADC reading to heart rate value (adc value range is 0..4095 -> hrvalue range is 20..183)
			# AJUSTAR ESTA ECUACION A LOS VALORES DE VOLTAJE QUE SE RECIBEN
            hrvalue = adcvalue/25 + 20
        else #error
            # if ADC read is unsuccessful, response value is 0
            hrvalue = 0
        end if
		
		hr_data(0:1)=0	# flags. zero means heart rate is sent as 8-bit value and no extra info is sent
		hr_data(count:1)=hrvalue	#Deformation value storage every 2ms and sended every 500ms to the app
			
    end if
	
    if handle = 0 then
        # the slow timer at 2Hz has lapsed
		count = 0

		#$ff: To all connected devices; xgatt_hr: characteristic handle;
        call gatt_server_send_characteristic_notification($ff, xgatt_hr, 2, hr_data(0:250))
		#LED TX on
		call hardware_write_gpio(led_port_TX,led_mask_TX,led_mask_TX)
		
		call endpoint_send(0,250,hr_data(0:250))
		
    end if

end

# generated when new connection is opened
event le_connection_opened(address,address_type,master,connection,bonding)
    call endpoint_send(0, 9, "Connect\r\n")

	# Write a message to UART interface to indicate SPP connection
    call endpoint_send(0,15,"HeartRate CONNECTED\r\n")
		
    connected = 1
	if connected = 1 then
		#Bluetooth led on when connection is on
		call hardware_write_gpio(led_port_Bluetooth,led_mask_Bluetooth,led_mask_Bluetooth)
	end if
	
end

# generated when the connection is closed
event le_connection_closed(reason,connection)

    call endpoint_send(0, 12, "Disconnect\r\n")

    # connection closed, restart advertisement
    call le_gap_set_mode(le_gap_general_discoverable, le_gap_undirected_connectable) 

    connected = 0
	
	if connected = 0 then
		#Bluetooth led off when connection is off
		call hardware_write_gpio(led_port_Bluetooth,led_mask_Bluetooth,$0000)
	end if
	
end
